#include<iostream>
using namespace std;
/*lambda expression(c++ 11, 14)
1. [캡쳐블럭] (매개변수 리스트) -> 리턴타입 {함수 바디}
2. 이름 없는 함수
3. 생략이 가능 한것  ①(매개변수 리스트) ② ->  ③ 리턴타입 
4. 필수 ①[캡쳐블럭] ②{함수바디}
5. 실행시키는 방법
   1) 람다식 + () 붙이기 
      : 맨끝의 소괄호 쌍은 람다표현식을 즉시 실행시키는 역할
      [캡쳐블럭] (매개변수 리스트) -> 리턴타입 {함수 바디}();

   2) 변수에 담아서 실행하기
      auto 변수이름 =  [캡쳐블럭] (매개변수 리스트) -> 리턴타입 {함수 바디};
	  
	  변수이름();
6. -> 리턴타입  [세트]
7. [캡쳐블럭] 
    : 람다함수 안에서 참조하려는 바깥변수들을 참조
	  매개변수로 받은 것 이외에 [캡쳐블럭]에 적은 변수들은 참조하여서 사용 가능
	* [캡쳐블럭] 활용하기
	1) [&해당변수] (매개변수 리스트) -> 리턴타입 {함수 바디};
	   [&해당변수]시 해당변수값 참조하여 함수 바디내에서 변경 가능

	2) [&] (매개변수 리스트) -> 리턴타입 {함수 바디};
	   [&]시 main에 있는 모든 변수에 대해 참조 가능 -> 모든 변수 참조하여서 사용가능(참조변수)
	   ※ 참조하여서 수정, 사용 가능

	3) [=] (매개변수 리스트) -> 리턴타입 {함수 바디};
	   [=]시 main에 있는 모든 변수에 대해 사용 가능 -> 모든 변수 사용가능(값)
		※ 값으로서 사용가능(수정 불가능)


*/

int main() {

	//short c = 5, d = 7;

	//auto inha = [&c, &d](float a, int b)-> int {
	//	c = -5;
	//	d = 8;
	//	return a + b + c + d; };

	////&C =>참조 형태 => 원본 수정 가능

	//cout << inha(1.9f, 2) << endl;

	short c = 5, d = 7;

	auto inha = [&](float a, int b)-> int { //main에 있는 모든 변수를 참조할수 있음(전체 변수 참조변수로 캡쳐)
		c = -5;
		d = 8;
		return a + b + c + d; };

	//&C =>참조 형태 => 원본 수정 가능

	cout << inha(1.9f, 2) << endl;



	auto inha2 = [=](float a, int b)-> int { //main에 있는 모든 변수를 사용가능(전체 변수 값으로 캡쳐)
		return a + b + c + d; };

	cout << inha2(1.9f, 2) << endl;


	auto inha3 = [=](float a, int b)-> int { //main에 있는 모든 변수를 사용가능(전체 변수 값으로 캡쳐)
		return a + b + c + d; }(1.9f, 2);

	cout << inha3 << endl;

	cout << typeid(inha).name() << endl;

	return 0;
}